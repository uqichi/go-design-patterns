# go-design-patterns
Go implementation for design patterns code based on [the book](https://www.amazon.co.jp/%E5%A2%97%E8%A3%9C%E6%94%B9%E8%A8%82%E7%89%88Java%E8%A8%80%E8%AA%9E%E3%81%A7%E5%AD%A6%E3%81%B6%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E5%85%A5%E9%96%80-%E7%B5%90%E5%9F%8E-%E6%B5%A9/dp/4797327030).

ref.
https://www.techscore.com/tech/DesignPattern/

## 2. Adapter
- 機能は似ているがインタフェースが異なるクラス同士を結合させる
- 継承パターンと委譲パターンの二つある
  - Goでは継承がないので委譲パターンしか実装できない
- 既存のクラスに一皮被せて利用したいとき
  - 既存に触れないでおくことができる
- バージョンアップと互換性に

## 3. Template Method
- ロジックを共通化
- Goでは継承がないので、実装の再利用はembedded fieldで、多相性はインターフェイスで実現する
- Goでは抽象クラスがないので、抽象クラスの実装メソッド的なのを使う場合は派生クラスのインスタンスを渡す必要がある

## 4. Factory Method
- インスタンスの作成をサブクラスに任せる
- フレームワークと肉付け
- フレームワークが肉付けに依存していないので、新たな肉付けの追加が簡単

## 8. Abstract Factory
- 抽象的な工場では、抽象的な部品を組み合わせて抽象的な製品を作る
- インタフェースだけを使って部品を組み立て、製品にまとめる
- 具体的な工場を新たに追加するのは簡単
- 部品を新たに追加するのは困難

## 9. Bridge
- 機能の階層と実装の階層を分けた上で結合させる
- 分けておけば、それぞれのクラス階層を独立に拡張することができる
  - 機能を足しても実装に影響はないし、逆も然り
  - 追加した機能は、全ての実装で利用できる

## 10. Strategy
- 委譲を使いアルゴリズムを容易に切り替える
- 実行環境によって切り替えることもできる